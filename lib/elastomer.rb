require 'tire'
require 'yaml'

# Elastomer provides an interface for indexing documents into a search engine
# and, subsequently, searching those documents.
#
module Elastomer
  extend self

  # Generic error class which acts as the superclass for all Elastomer errors.
  # You can rescue this error to trap any exception generated by the Elastomer
  # library.
  #
  Error = Class.new StandardError

  # This error is raised when attempting to lookup an adapter that does not
  # exist in the Elastomer::Adapters namespace.
  #
  UnknownAdapter = Class.new Error

  # This error is raised when attempting to lookup an Index that does not
  # exist in the Elastomer::Indexes namespace.
  #
  UnknownIndex = Class.new Error

  # Namespace for the various data adapters. Each adapter is responsible for
  # one type of document that will be indexed into ElasticSearch. The adapter
  # retrieves information from the database (or the data store of choice) and
  # collates the information into a format that can be indexed by
  # ElasticSearch.
  #
  # Adapters perform the 'extract' and 'transform' steps. The loading of the
  # data is performed by one of the Index instance found in the Indexes
  # namespace.
  #
  module Adapters; end

  # Namespace for the separate indexes maintained by the library. Each index
  # in ElasticSearch should have a representative class in this module. The
  # class defines the [mappings](http://www.elasticsearch.org/guide/reference/mapping/)
  # for the stored documents and the [settings](http://www.elasticsearch.org/guide/reference/index-modules/)
  # for the index itself.
  #
  module Indexes
    extend self

    # Public: A Hash of document types that map to the index they are
    # associated with. Each index is responsible for registering the document
    # types it handles.
    #
    # Examples
    #
    #   document_index_map['issue']     = ::Elastomer::Indexes::Issues
    #   document_index_map['milestone'] = ::Elastomer::Indexes::Issues
    #
    # Returns the Hash mapping document types to their index location.
    #
    def document_index_map
      @document_index_map ||= Hash.new
    end
  end

  # Public: Perform setup related to the ElasticSearch index.
  #
  # opts - The Hash of options.
  #        :url - The URL String of the ElasticSearch server
  #
  # Examples
  #
  #   Elastomer.setup( :url => 'http://localhost:9200' )
  #
  # Returns nil.
  #
  def setup( options = {} )
    default_url = "http://localhost:#{ENV['GH_ELASTICSEARCH_PORT'] || 9200}"
    Tire::Configuration.url(options.fetch(:url, default_url))
    Tire::Configuration.wrapper(Hash)
    nil
  end

  # Public: Connect to the ElasticSearch server and return true if it is
  # available and ready for requests.
  #
  # Returns true if the ElasticSearch server is up and running.
  #
  def available?
    return false if Rails.env.test? || GitHub.enterprise?
    return @available if defined? @available and @available

    conn = Faraday.new(Tire::Configuration.url)
    response = conn.get { |req|
      req.options[:timeout] = 2
      req.options[:open_timeout] = 2
    }

    @available = response.success?
  rescue StandardError
    return false
  end

  # Public: Obtain an Index instance either by name or by an adapter object.
  # For an example of how this method is used, look at the
  # `add_to_search_index` method below.
  #
  # obj - Either a String, an Adapter class, or an Adapter instance.
  #
  # Examples
  #
  #   Elastomer.index( 'issues' )
  #   # => Elastomer::Indexes::Issues
  #
  #   Elastomer.index( Elastomer::Adapters::Milestone )
  #   # => <Elastomer::Indexes::Issues:0x109c7c888>
  #
  #   issue = Elastomer::Adapters::Issue.new(1234)
  #   Elastomer.index(issue)
  #   # => <Elastomer::Indexes::Issues:0x109c7c888>
  #
  # Returns the requested Index instance.
  #
  def index( obj )
    if String === obj
      classname = obj.split('::').last.gsub(/(?:^|_)(.)/) { $1.upcase }
      unless Indexes.const_defined? classname
        raise UnknownIndex, "Elastomer::Indexes::#{classname} does not exist"
      end
      return Indexes.const_get(classname).new
    end

    name = (Class === obj) ? obj.name : obj.class.name
    name = name.split('::').last

    name.gsub!(/([A-Z]+)([A-Z][a-z])/, '\1_\2')
    name.gsub!(/([a-z\d])([A-Z])/, '\1_\2')
    name.tr!('-', '_')
    name.downcase!

    Indexes.document_index_map.fetch(name).new

  rescue IndexError
    raise UnknownIndex, "The document type `#{name}' is not mapped to any index"
  end

  # Public: Given an adapter name return the adapter Class.
  #
  # type - The adapter name as a String
  #
  # Returns the Class for the requested adapter.
  # Raises Elastomer::UnknownAdapter if the adapter type does not exist.
  #
  def adapter( type )
    classname = type.split('::').last.gsub(/(?:^|_)(.)/) { $1.upcase }
    Adapters.const_get(classname)
  rescue NameError
    raise UnknownAdapter, "Elastomer::Adapters::#{classname} does not exist"
  end

  # Public: Given an adapter object, add the document returned by the adapter
  # to the correct search index.
  #
  # adapter - The adapter instance to add to the search index
  #
  # Returns the Hash response from the ElasticSearch server or `nil` if the
  # document could not be stored.
  #
  def add_to_search_index( adapter )
    return if adapter.nil?

    index = ::Elastomer.index(adapter)
    index.store(adapter)
  end

  # Public: Given an adapter object, remove the document from the search
  # index.
  #
  # adapter - The adapter instance to remove from the search index
  #
  # Returns the Hash response from the ElasticSearch server.
  #
  def remove_from_search_index( adapter )
    return if adapter.nil?

    index = ::Elastomer.index(adapter)
    index.remove(adapter)
  end

  # Public: Sanitize text for a Lucene index by removing unprintable
  # characters.
  #
  # text - The String text to sanitize.
  #
  # Returns the sanitized String.
  #
  def sanitize( text )
    text.to_s.gsub(/[\x00-\x08\x0B\x0C\x0E-\x1F]/, '')
  end

  # Public: Take a chunk of markdown text and remove all markdown syntax
  # leaving only the plain text.
  #
  # text - The String text to clean of markdown syntax.
  #
  # Returns the plain-text String.
  #
  def clean_markdown( text )
    text = text.to_s
    return text if text.empty?

    GitHub::Markdown.to_html(text, :plaintext)
  end

  # Public: Take a chunk of markdown text and remove all markdown syntax
  # leaving only the plain text; the plain text is then stripped of any
  # unprintable characters.
  #
  # text - The String text to clean of markdown syntax and sanitize.
  #
  # Returns the sanitized plain-text String.
  #
  def clean_and_sanitize( text )
    sanitize(clean_markdown(text))
  end

  # Public: The Lucene QueryParser applies special meaning to several
  # characters when it is parsing a query string. If these characters are used
  # inappropriately the query will produce an error. The solution is to escape
  # these characters before passing the query string to ElasticSearch.
  #
  # The following special characters will be escaped with a leading backslash
  # by this method:
  #
  #    + - & | ! ( ) { } [ ] ^  ~ * ? : \
  #
  # The quote " character has been omitted from the list allowing the user to
  # use quotes in their queries.
  #
  # text - The String that will have special characters escaped.
  # all  - Force double quotes to be escaped as well.
  #
  # Examples
  #
  #   escape_characters( "foo & bar :baz -info" )
  #   #=> "foo \& bar \:baz \-info"
  #
  # Returns a new String with Lucene special characters escaped.
  #
  def escape_characters( text, all = false )
    if all
      text.to_s.gsub(/([#{Regexp.escape('+-&|!()[]{}^~*?:"')}]|\\(.))/, '\\\\\1')
    else
      text.to_s.gsub(/([#{Regexp.escape('+-&|!()[]{}^~*?:')}]|\\(?!"))/, '\\\\\1')
    end
  end

  # Public: Given a query string (passed on usually from a web form) parse out
  # colon delimited fields from the query. The fields are used to refine the
  # query when it is passed to the search index.
  #
  # The fields to parse from the query string are given as an array of strings
  # or symbols.
  #
  # text - The String of text to parse for query fields
  # args - An optional array of fields (as Strings or Symbols) to parse from the text
  #
  # Examples
  #
  #   parse_query( "foo bar baz" )
  #   #=> "foo bar baz"
  #
  #   parse_query( "Chris followers:75", :followers )
  #   #=> ["Chris", { :followers => 75 }]
  #
  #   parse_query( "require 'bundler' fork:false language:ruby", :fork, :language )
  #   #=> ["require 'bundler'", { :fork => 'false', :language => 'ruby' }]
  #
  #   parse_query( "literal query \"repos:44\" language:java", :repos, :language )
  #   #=> ["literal query \"repos:44\"", { :language => 'java' }]
  #
  #   parse_query( "range query followers:[25 TO 50] language:java", :followers, :language )
  #   #=> ["range query", { :followers => '[25 TO 50]', :language => 'java' }]
  #
  #   parse_query( "location:Boulder location:\"San Francisco\"", :location )
  #   #=> ["", { :location => ["Boulder", "San Francisco"] }]
  #
  # Returns an Array containing the query String and the Hash of fields keyed
  # as Symbols.
  #
  def parse_query( text, *args )
    return text if args.empty?

    fields = {}
    query = ''
    scanner = StringScanner.new(text.to_s)
    fields_rgxp = /(?:^|\s)(-?(?:#{args.flatten.uniq.join('|')})):(\[[^\]]+\]|"([^"]+)"|\S+)/

    until scanner.eos?
      # look for fields in the query text
      if scanner.scan(fields_rgxp)
        key = scanner[1].to_sym
        value = scanner[3] || scanner[2]

        if fields.key? key
          if fields[key].is_a? Array then fields[key] << value
          else fields[key] = [fields[key], value] end
        else
          fields[key] = value
        end

      # look for escaped characters
      elsif scanner.scan(/\\/)
        query << scanner[0]
        query << scanner.getch unless scanner.eos?

      # look for literal strings (inside double quotes)
      elsif scanner.scan(/"/)
        query << scanner[0]
        query << scanner.scan_until(/(^|[^\\])"/).to_s

      # otherwise this is part of the query
      else
        query << scanner.getch
      end
    end

    query.strip!
    [query, fields]
  end

end  # Elastomer

require 'elastomer/adapter'
require 'elastomer/index'
require 'elastomer/loader'
require 'elastomer/version'
